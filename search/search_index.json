{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"MicroPython \u00b6 Reference \u00b6 Basic steps to get started with MicroPython: Flash MicroPython firmware on ESP32 microcontroller Upload code with ampy Monitor from serial console Use WebREPL for remote serial connectivity Tutorials \u00b6 blink - \"hello world\" for MicroPython LED dimming with PWM - mqtt SSD1306 OLED motion- HC-SR501 Projects \u00b6 room temp sensor room temp sensor with CO2 bucket mouse trap with motion sensor - TBD Arduino \u00b6 Reference \u00b6 Flash firmware - TBD PlatformIO - TBD OTA updates - TBD Projects \u00b6 leak sensor room temp sensor garage manager doorbell - replacement for standard doorbell chime with do-not-disturb settings, MQTT notifications, and indoor motion sensor plant water Home Automation Software \u00b6 Backend - MQTT, NodeRed, and Prometheus (TBD) Dashboard - Grafana (TBD) Alerts - Slack, NodeRed, Prometheus AlertManager (TBD) MQTT buttons - NodeRed, Home Assistant (TBD) Zwave - NodeRed and ZWave-JS (TBD) Tasmota - Tasmota and NodeRed (TBD) Ansible \u00b6 port_scan_facts - Ansible role to test TCP port connectivity and return the results as Ansible facts chrony - Ansible role to install and configure chrony for NTP time synchronization auto_patch - Ansible role sets up a cron job to automatically apply updates and optionally reboot if required k8s-cluster-setup - Ansible playbooks to setup a Kubernetes cluster Other Python projects \u00b6 prom-sudo-events - Prometheus exporter written in Python that tails journald to generate metrics (sudo chosen for testing) perf-linux - One of my first Python projects to grab detailed performance data for 1 minute and create a report on system performance with built in analysis for certain conditions","title":"Home"},{"location":"index.html#micropython","text":"","title":"MicroPython"},{"location":"index.html#reference","text":"Basic steps to get started with MicroPython: Flash MicroPython firmware on ESP32 microcontroller Upload code with ampy Monitor from serial console Use WebREPL for remote serial connectivity","title":"Reference"},{"location":"index.html#tutorials","text":"blink - \"hello world\" for MicroPython LED dimming with PWM - mqtt SSD1306 OLED motion- HC-SR501","title":"Tutorials"},{"location":"index.html#projects","text":"room temp sensor room temp sensor with CO2 bucket mouse trap with motion sensor - TBD","title":"Projects"},{"location":"index.html#arduino","text":"","title":"Arduino"},{"location":"index.html#reference_1","text":"Flash firmware - TBD PlatformIO - TBD OTA updates - TBD","title":"Reference"},{"location":"index.html#projects_1","text":"leak sensor room temp sensor garage manager doorbell - replacement for standard doorbell chime with do-not-disturb settings, MQTT notifications, and indoor motion sensor plant water","title":"Projects"},{"location":"index.html#home-automation-software","text":"Backend - MQTT, NodeRed, and Prometheus (TBD) Dashboard - Grafana (TBD) Alerts - Slack, NodeRed, Prometheus AlertManager (TBD) MQTT buttons - NodeRed, Home Assistant (TBD) Zwave - NodeRed and ZWave-JS (TBD) Tasmota - Tasmota and NodeRed (TBD)","title":"Home Automation Software"},{"location":"index.html#ansible","text":"port_scan_facts - Ansible role to test TCP port connectivity and return the results as Ansible facts chrony - Ansible role to install and configure chrony for NTP time synchronization auto_patch - Ansible role sets up a cron job to automatically apply updates and optionally reboot if required k8s-cluster-setup - Ansible playbooks to setup a Kubernetes cluster","title":"Ansible"},{"location":"index.html#other-python-projects","text":"prom-sudo-events - Prometheus exporter written in Python that tails journald to generate metrics (sudo chosen for testing) perf-linux - One of my first Python projects to grab detailed performance data for 1 minute and create a report on system performance with built in analysis for certain conditions","title":"Other Python projects"},{"location":"Home_Automation_Software/alerts.html","text":"Alerts \u00b6 Slack, NodeRed, Prometheus AlertManager","title":"Alerts"},{"location":"Home_Automation_Software/alerts.html#alerts","text":"Slack, NodeRed, Prometheus AlertManager","title":"Alerts"},{"location":"Home_Automation_Software/backend.html","text":"Home Automation Backend \u00b6 MQTT, NodeRed, and Prometheus","title":"Home Automation Backend"},{"location":"Home_Automation_Software/backend.html#home-automation-backend","text":"MQTT, NodeRed, and Prometheus","title":"Home Automation Backend"},{"location":"Home_Automation_Software/dashboard.html","text":"Dashboard \u00b6 Grafana","title":"Dashboard"},{"location":"Home_Automation_Software/dashboard.html#dashboard","text":"Grafana","title":"Dashboard"},{"location":"Home_Automation_Software/mqtt_buttons.html","text":"MQTT Buttons \u00b6 NodeRed, Home Assistant","title":"MQTT Buttons"},{"location":"Home_Automation_Software/mqtt_buttons.html#mqtt-buttons","text":"NodeRed, Home Assistant","title":"MQTT Buttons"},{"location":"Home_Automation_Software/tasmota.html","text":"Tasmota \u00b6 Tasmota and NodeRed","title":"Tasmota"},{"location":"Home_Automation_Software/tasmota.html#tasmota","text":"Tasmota and NodeRed","title":"Tasmota"},{"location":"Home_Automation_Software/zwave.html","text":"ZWave \u00b6 NodeRed and ZWave-JS","title":"ZWave"},{"location":"Home_Automation_Software/zwave.html#zwave","text":"NodeRed and ZWave-JS","title":"ZWave"},{"location":"MicroPython/WebREPL.html","text":"WebREPL \u00b6 webrepl is not enabled by default. WebREPL is great for remotely managing a MicroPython controller connected to the network without the need for a serial port connection. Most online documentation says to run import webrepl from a REPL shell and follow the prompts. This isn't really neccessary as it's better to have more control over the setup process, which can be copied from project to project. Create file with webrepl password and upload \u00b6 echo \"PASS = 'password'\" > webrepl_cfg.py ampy --port /dev/ttyUSB0 --baud 115200 put webrepl_cfg.py import webrepl \u00b6 At the top of main.py with other import statements: import webrepl start webrepl \u00b6 Add the following to main.py after WiFi is connected and print(station.ifconfig()) runs successfully: webrepl.start() webrepl client tool \u00b6 The client tool is hosted at http://micropython.org/webrepl/ . It runs locally from the browser. It's recommended to make a DHCP reservation for the MAC/IP so the IP address can be consistently used for remote connections.","title":"WebREPL"},{"location":"MicroPython/WebREPL.html#webrepl","text":"webrepl is not enabled by default. WebREPL is great for remotely managing a MicroPython controller connected to the network without the need for a serial port connection. Most online documentation says to run import webrepl from a REPL shell and follow the prompts. This isn't really neccessary as it's better to have more control over the setup process, which can be copied from project to project.","title":"WebREPL"},{"location":"MicroPython/WebREPL.html#create-file-with-webrepl-password-and-upload","text":"echo \"PASS = 'password'\" > webrepl_cfg.py ampy --port /dev/ttyUSB0 --baud 115200 put webrepl_cfg.py","title":"Create file with webrepl password and upload"},{"location":"MicroPython/WebREPL.html#import-webrepl","text":"At the top of main.py with other import statements: import webrepl","title":"import webrepl"},{"location":"MicroPython/WebREPL.html#start-webrepl","text":"Add the following to main.py after WiFi is connected and print(station.ifconfig()) runs successfully: webrepl.start()","title":"start webrepl"},{"location":"MicroPython/WebREPL.html#webrepl-client-tool","text":"The client tool is hosted at http://micropython.org/webrepl/ . It runs locally from the browser. It's recommended to make a DHCP reservation for the MAC/IP so the IP address can be consistently used for remote connections.","title":"webrepl client tool"},{"location":"MicroPython/ampy.html","text":"ampy \u00b6 install \u00b6 Make sure user is in the dialout group to have write permissions to the /dev/ttyUSB0 device. Install Python modules for ampy (can use Python virtualenv or install globally since it shouldn't conflict with anything else) pip3 install adafruit-ampy pip3 install rshell upload \u00b6 ampy --port /dev/ttyUSB0 --baud 115200 put boot.py ampy --port /dev/ttyUSB0 --baud 115200 put main.py ampy --port /dev/ttyUSB0 --baud 115200 put ssd1306.py download \u00b6 ampy --port /dev/ttyUSB0 --baud 115200 get boot.py > boot.py.bak list files \u00b6 ampy --port /dev/ttyUSB0 --baud 115200 ls remove \u00b6 ampy --port /dev/ttyUSB0 --baud 115200 rm BME280.py run local script on microcontroller \u00b6 ampy --port /dev/ttyUSB0 --baud 115200 run main.py","title":"ampy"},{"location":"MicroPython/ampy.html#ampy","text":"","title":"ampy"},{"location":"MicroPython/ampy.html#install","text":"Make sure user is in the dialout group to have write permissions to the /dev/ttyUSB0 device. Install Python modules for ampy (can use Python virtualenv or install globally since it shouldn't conflict with anything else) pip3 install adafruit-ampy pip3 install rshell","title":"install"},{"location":"MicroPython/ampy.html#upload","text":"ampy --port /dev/ttyUSB0 --baud 115200 put boot.py ampy --port /dev/ttyUSB0 --baud 115200 put main.py ampy --port /dev/ttyUSB0 --baud 115200 put ssd1306.py","title":"upload"},{"location":"MicroPython/ampy.html#download","text":"ampy --port /dev/ttyUSB0 --baud 115200 get boot.py > boot.py.bak","title":"download"},{"location":"MicroPython/ampy.html#list-files","text":"ampy --port /dev/ttyUSB0 --baud 115200 ls","title":"list files"},{"location":"MicroPython/ampy.html#remove","text":"ampy --port /dev/ttyUSB0 --baud 115200 rm BME280.py","title":"remove"},{"location":"MicroPython/ampy.html#run-local-script-on-microcontroller","text":"ampy --port /dev/ttyUSB0 --baud 115200 run main.py","title":"run local script on microcontroller"},{"location":"MicroPython/deep_sleep.html","text":"Deep Sleep \u00b6 Save variables to flash \u00b6 Flash memory has limited write cycles around 10,000. RTC memory contains a Python dictionary with 64 key/value pairs. The dictionary keys are integers 0-63. There is also one RTC variable for storing a string. There isn't a lot of documentation on this. import machine import ujson rtc = machine.RTC() d = {1:'one', 2:'two'} # Example data to save rtc.memory(ujson.dumps(d)) # Save in RTC RAM r = ujson.loads(rtc.memory()) # Restore from RTC RAM # r == {2: 'two', 1: 'one'}","title":"Deep Sleep"},{"location":"MicroPython/deep_sleep.html#deep-sleep","text":"","title":"Deep Sleep"},{"location":"MicroPython/deep_sleep.html#save-variables-to-flash","text":"Flash memory has limited write cycles around 10,000. RTC memory contains a Python dictionary with 64 key/value pairs. The dictionary keys are integers 0-63. There is also one RTC variable for storing a string. There isn't a lot of documentation on this. import machine import ujson rtc = machine.RTC() d = {1:'one', 2:'two'} # Example data to save rtc.memory(ujson.dumps(d)) # Save in RTC RAM r = ujson.loads(rtc.memory()) # Restore from RTC RAM # r == {2: 'two', 1: 'one'}","title":"Save variables to flash"},{"location":"MicroPython/flash_firmware.html","text":"Flash Firmware \u00b6 Download \u00b6 https://micropython.org/download/esp32/ Use firmware built with ESP-IDF v4.x Erase flash \u00b6 $ esptool.py --port /dev/ttyUSB0 erase_flash esptool.py v3.1 Serial port /dev/ttyUSB0 Connecting........_____....._____.....__ Detecting chip type... ESP32 Chip is ESP32-D0WDQ6 ( revision 1 ) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: 4c:11:ae:73:de:54 Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 9 .6s Hard resetting via RTS pin... Write firmware \u00b6 $ esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 460800 write_flash -z 0x1000 ~/Downloads/esp32-20210902-v1.17.bin 0800 write_flash -z 0x1000 ~/Downloads/esp32-20210902-v1.17.bin esptool.py v3.1 Serial port /dev/ttyUSB0 Connecting........___ Chip is ESP32-D0WDQ6 ( revision 1 ) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: 4c:11:ae:73:de:54 Uploading stub... Running stub... Stub running... Changing baud rate to 460800 Changed. Configuring flash size... Flash will be erased from 0x00001000 to 0x00175fff... Compressed 1527504 bytes to 987584 ... Wrote 1527504 bytes ( 987584 compressed ) at 0x00001000 in 22 .8 seconds ( effective 536 .1 kbit/s ) ... Hash of data verified. Leaving... Hard resetting via RTS pin...","title":"Flash Firmware"},{"location":"MicroPython/flash_firmware.html#flash-firmware","text":"","title":"Flash Firmware"},{"location":"MicroPython/flash_firmware.html#download","text":"https://micropython.org/download/esp32/ Use firmware built with ESP-IDF v4.x","title":"Download"},{"location":"MicroPython/flash_firmware.html#erase-flash","text":"$ esptool.py --port /dev/ttyUSB0 erase_flash esptool.py v3.1 Serial port /dev/ttyUSB0 Connecting........_____....._____.....__ Detecting chip type... ESP32 Chip is ESP32-D0WDQ6 ( revision 1 ) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: 4c:11:ae:73:de:54 Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 9 .6s Hard resetting via RTS pin...","title":"Erase flash"},{"location":"MicroPython/flash_firmware.html#write-firmware","text":"$ esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 460800 write_flash -z 0x1000 ~/Downloads/esp32-20210902-v1.17.bin 0800 write_flash -z 0x1000 ~/Downloads/esp32-20210902-v1.17.bin esptool.py v3.1 Serial port /dev/ttyUSB0 Connecting........___ Chip is ESP32-D0WDQ6 ( revision 1 ) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: 4c:11:ae:73:de:54 Uploading stub... Running stub... Stub running... Changing baud rate to 460800 Changed. Configuring flash size... Flash will be erased from 0x00001000 to 0x00175fff... Compressed 1527504 bytes to 987584 ... Wrote 1527504 bytes ( 987584 compressed ) at 0x00001000 in 22 .8 seconds ( effective 536 .1 kbit/s ) ... Hash of data verified. Leaving... Hard resetting via RTS pin...","title":"Write firmware"},{"location":"MicroPython/libraries.html","text":"Libraries \u00b6 Note about MicroPython and I2C \u00b6 In my experience, I've had more issues with multiple devices on a single I2C bus with Micropython than with Arduino. A lot of forums say additional resistors are needed or blame the hardware or the drivers. The same hardware configurations worked reliably for almost a year with Arduino before I started flashing microcontrollers with MicroPython. The easy fix was to just use SoftI2C and put the 2 nd I2C device on another software-defined bus. This could present issues if trying to use more than a few I2C devices, but it has worked reliably. mqtt library \u00b6 wget https://raw.githubusercontent.com/pycom/pycom-libraries/master/examples/mqtt/mqtt.py ampy --port /dev/ttyUSB0 --baud 115200 put mqtt.py SSD1306 OLED library \u00b6 wget https://raw.githubusercontent.com/micropython/micropython/master/drivers/display/ssd1306.py ampy --port /dev/ttyUSB0 --baud 115200 put ssd1306.py BME280 library \u00b6 wget https://github.com/RuiSantosdotme/ESP-MicroPython/blob/master/code/WiFi/HTTP_Client_IFTTT_BME280/BME280.py ampy --port /dev/ttyUSB0 --baud 115200 put BME280.py AHT10 library \u00b6 wget https://raw.githubusercontent.com/targetblank/micropython_ahtx0/master/ahtx0.py ampy --port /dev/ttyUSB0 --baud 115200 put ahtx0.py","title":"Libraries"},{"location":"MicroPython/libraries.html#libraries","text":"","title":"Libraries"},{"location":"MicroPython/libraries.html#note-about-micropython-and-i2c","text":"In my experience, I've had more issues with multiple devices on a single I2C bus with Micropython than with Arduino. A lot of forums say additional resistors are needed or blame the hardware or the drivers. The same hardware configurations worked reliably for almost a year with Arduino before I started flashing microcontrollers with MicroPython. The easy fix was to just use SoftI2C and put the 2 nd I2C device on another software-defined bus. This could present issues if trying to use more than a few I2C devices, but it has worked reliably.","title":"Note about MicroPython and I2C"},{"location":"MicroPython/libraries.html#mqtt-library","text":"wget https://raw.githubusercontent.com/pycom/pycom-libraries/master/examples/mqtt/mqtt.py ampy --port /dev/ttyUSB0 --baud 115200 put mqtt.py","title":"mqtt library"},{"location":"MicroPython/libraries.html#ssd1306-oled-library","text":"wget https://raw.githubusercontent.com/micropython/micropython/master/drivers/display/ssd1306.py ampy --port /dev/ttyUSB0 --baud 115200 put ssd1306.py","title":"SSD1306 OLED library"},{"location":"MicroPython/libraries.html#bme280-library","text":"wget https://github.com/RuiSantosdotme/ESP-MicroPython/blob/master/code/WiFi/HTTP_Client_IFTTT_BME280/BME280.py ampy --port /dev/ttyUSB0 --baud 115200 put BME280.py","title":"BME280 library"},{"location":"MicroPython/libraries.html#aht10-library","text":"wget https://raw.githubusercontent.com/targetblank/micropython_ahtx0/master/ahtx0.py ampy --port /dev/ttyUSB0 --baud 115200 put ahtx0.py","title":"AHT10 library"},{"location":"MicroPython/serial_console.html","text":"Serial Consoles \u00b6 screen \u00b6 The screen command is used to connect to the serial port. It's important to know that you cannot upload with ampy while attached to the serial port with screen so this process gets pretty repetitive. WebREPL might work around some of this, but it seems a little more clunky than mastering these steps. screen install \u00b6 sudo apt-get install -y screen Attach to USB port with screen \u00b6 screen /dev/ttyUSB0 115200 After attaching to USB port, press \"Enter\" to get Python shell (see Python shell help below). Once in the screen session and in the python shell (not screen command), press Ctrl-D to soft-reboot after uploading a file. You cannot upload a file with ampy if screen is also attached via the serial port. Exit screen (kill screen). \u00b6 This command kills the screen session to free up the serial port (so files can be uploaded with ampy/put) The Ctrl-a is the default escape key to send the command to screen (not for Python shell). Ctrl-a, k Python shell help \u00b6 Ctrl-D is useful. >>> help() Welcome to MicroPython on the ESP32! For generic online docs please visit http://docs.micropython.org/ For access to the hardware use the 'machine' module: import machine pin12 = machine.Pin(12, machine.Pin.OUT) pin12.value(1) pin13 = machine.Pin(13, machine.Pin.IN, machine.Pin.PULL_UP) print(pin13.value()) i2c = machine.I2C(scl=machine.Pin(21), sda=machine.Pin(22)) i2c.scan() i2c.writeto(addr, b'1234') i2c.readfrom(addr, 4) Basic WiFi configuration: import network sta_if = network.WLAN(network.STA_IF); sta_if.active(True) sta_if.scan() # Scan for available access points sta_if.connect(\"<AP_name>\", \"<password>\") # Connect to an AP sta_if.isconnected() # Check for successful connection Control commands: CTRL-A -- on a blank line, enter raw REPL mode CTRL-B -- on a blank line, enter normal REPL mode CTRL-C -- interrupt a running program CTRL-D -- on a blank line, do a soft reset of the board CTRL-E -- on a blank line, enter paste mode For further help on a specific object, type help(obj) For a list of available modules, type help('modules') >>>","title":"Serial Consoles"},{"location":"MicroPython/serial_console.html#serial-consoles","text":"","title":"Serial Consoles"},{"location":"MicroPython/serial_console.html#screen","text":"The screen command is used to connect to the serial port. It's important to know that you cannot upload with ampy while attached to the serial port with screen so this process gets pretty repetitive. WebREPL might work around some of this, but it seems a little more clunky than mastering these steps.","title":"screen"},{"location":"MicroPython/serial_console.html#screen-install","text":"sudo apt-get install -y screen","title":"screen install"},{"location":"MicroPython/serial_console.html#attach-to-usb-port-with-screen","text":"screen /dev/ttyUSB0 115200 After attaching to USB port, press \"Enter\" to get Python shell (see Python shell help below). Once in the screen session and in the python shell (not screen command), press Ctrl-D to soft-reboot after uploading a file. You cannot upload a file with ampy if screen is also attached via the serial port.","title":"Attach to USB port with screen"},{"location":"MicroPython/serial_console.html#exit-screen-kill-screen","text":"This command kills the screen session to free up the serial port (so files can be uploaded with ampy/put) The Ctrl-a is the default escape key to send the command to screen (not for Python shell). Ctrl-a, k","title":"Exit screen (kill screen)."},{"location":"MicroPython/serial_console.html#python-shell-help","text":"Ctrl-D is useful. >>> help() Welcome to MicroPython on the ESP32! For generic online docs please visit http://docs.micropython.org/ For access to the hardware use the 'machine' module: import machine pin12 = machine.Pin(12, machine.Pin.OUT) pin12.value(1) pin13 = machine.Pin(13, machine.Pin.IN, machine.Pin.PULL_UP) print(pin13.value()) i2c = machine.I2C(scl=machine.Pin(21), sda=machine.Pin(22)) i2c.scan() i2c.writeto(addr, b'1234') i2c.readfrom(addr, 4) Basic WiFi configuration: import network sta_if = network.WLAN(network.STA_IF); sta_if.active(True) sta_if.scan() # Scan for available access points sta_if.connect(\"<AP_name>\", \"<password>\") # Connect to an AP sta_if.isconnected() # Check for successful connection Control commands: CTRL-A -- on a blank line, enter raw REPL mode CTRL-B -- on a blank line, enter normal REPL mode CTRL-C -- interrupt a running program CTRL-D -- on a blank line, do a soft reset of the board CTRL-E -- on a blank line, enter paste mode For further help on a specific object, type help(obj) For a list of available modules, type help('modules') >>>","title":"Python shell help"}]}